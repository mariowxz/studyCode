#构造函数与原型
  ES6之前的类都是通过构造函数实现
  ##构造函数
	1，构造函数用户创建一类对象，其首字母要大写
	2，构造函数要和new一起使用才有意义
	3，执行构造函数里面的代码，给这个新对象添加属性和方法
	4，返回这个新对象（所以构造函数里面不要return）
	
   ###实例成员
		实例成员只能通过实例化的对象来访问
		不可以通过构造函数来访问实例成员
   ###静态成员
		构造函数本身上添加的成员
		实例成员只能通过构造函数来访问
		
   ###缺点
		很好用，但是存在浪费内存的问题 
		
  ##构造函数原型 prototype
		构造函数通过原型分配的函数是所有对象所共享的
		JavaScript规定，每一个构造函数都有一个prototype属性，指向另一个对象。注意这个prototype就是一个对象，这个对象的所有属性和方法，都会被
		构造函数所拥有。
		
		我们可以把那些不变的方法，直接定义在prototype对象上，这样所有对象的实例就可以共享这些方法。解决了浪费内存的问题
		
  ##对象原型 __proto__
		对象都会有一个属性__proto__，指向构造函数的prototype原型对象，之所以我们对象可以使用构造函数，prototype原型对象的属性和方法，就是因为
		对象要__proto__原型的存在
		
   ###__proto__和prototype对比
   
		1:(实例化对象.__proto__) === (类.prototype)
		   __proto__对象原型和原型对象prototype是等价的 
		   
		2:__proto__对象原型的意义就在于为对象查找机会制造一个方向，或者说一条线，但是它是一个非标准属性，因此实际开发中，
			不可以使用这个属性，它只是内部指向原型对象prototype

		
		
		方法查找规则：首先看实例化对象是否有这个方法，如果有就执行这个方法，如果没有这个方法，
				   因为有__proto__的存在，就去构造函数原型对象prototype身上去查找这个方法
	
   ###__proto__和prototype都有一个属性constructor：它指回构造函数本身
		constructor主要用于记录该对象引用于哪个构造函数，它可以让原型对象重新指向原来的构造函数
		
   ###构造函数 实例 原型对象 之间的三角关系				   
   
   ###原型链
		任意类原型对象prototype里面的__proto__原型指向的是 Object.prototype
		 Object.prototype.__proto__指向的是null 已经到底了 
   ###this指向问题
		1，构造函数里面 this指向实例化对象
		2，原型对象函数里面this指向的是实例化对象
   ###扩展内置对象
		可以通过原型对象，对原来的内置对象进行扩展自定义的方法，比如给数组增加自定义求偶数和的功能 Array.prototype
#继承
  ES6之前的类都是通过构造函数+原型对象模拟实现继承 也叫组合继承
  
  ##call()
  
#ES5中新增的一些方法